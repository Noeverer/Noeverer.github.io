---
title: 动态注册
date: 2025-08-29 12:00:00
tags: ["code", "python", "动态注册"]
categories: code
description: 动态注册
published: true
---

# 引用python代码文件
[cls-test.py](/resources/openmanus/cls-test.py)
[model_validator_test.py](/resources/openmanus/model_validator_test.py)
[property_example.py](/resources/openmanus/property_example.py)


<details>
<summary>点击查看 cls-test.py</summary>

```python
# cls-test.py 内容
class TestClass:
    def __init__(self):
        self.name = "test"

    def display(self):
        print(f"This is a {self.name} class")
```
</details>



## `self.server.tool()(tool_method)` 注册原理详解

这是一种**装饰器模式**的使用方式，让我用简单代码来解释其原理：

### 1. 装饰器基本原理

```python
# 最简单的装饰器示例
def my_decorator(func):
    def wrapper():
        print("执行前")
        func()
        print("执行后")
    return wrapper

@my_decorator  # 等价于 say_hello = my_decorator(say_hello)
def say_hello():
    print("Hello!")

say_hello()
# 输出:
# 执行前
# Hello!
# 执行后
```

### 2. 带参数的装饰器工厂

```python
# 装饰器工厂 - 返回装饰器的函数
def tool_registry(name):
    def decorator(func):
        print(f"注册工具: {name}")
        func.registered_name = name  # 给函数添加属性
        return func
    return decorator

# 使用装饰器工厂
@tool_registry("计算器")
def calculator(a, b):
    return a + b

print(calculator.registered_name)  # 输出: 计算器
```

### 3. 与源码中用法等价的简单实现

```python
class SimpleServer:
    def __init__(self):
        self.tools = {}
    
    def tool(self):
        # 这是一个装饰器工厂，返回真正的装饰器
        def decorator(func):
            # 将函数注册到服务器中
            self.tools[func.__name__] = func
            print(f"已注册工具: {func.__name__}")
            return func
        return decorator

# 创建服务器实例
server = SimpleServer()

# 定义工具函数
async def add_numbers(a: int, b: int):
    return a + b

# 注册工具 - 这与源码中的用法完全一致
server.tool()(add_numbers)  # 等价于 server.tools["add_numbers"] = add_numbers

# 验证注册成功
print(server.tools.keys())  # 输出: dict_keys(['add_numbers'])
```

### 4. 动态创建并注册函数

```python
class SimpleServer:
    def __init__(self):
        self.tools = {}
    
    def tool(self):
        def decorator(func):
            self.tools[func.__name__] = func
            return func
        return decorator

server = SimpleServer()

# 动态创建函数并注册（与源码中做法一致）
def create_and_register_tool(tool_name, logic_func):
    # 动态创建函数
    async def tool_func(**kwargs):
        print(f"执行工具: {tool_name}")
        return await logic_func(**kwargs)
    
    # 设置函数名称
    tool_func.__name__ = tool_name
    
    # 注册到服务器 - 这就是源码中的关键步骤
    server.tool()(tool_func)

# 使用示例
async def multiply_logic(x, y):
    return x * y

create_and_register_tool("multiply", multiply_logic)

# 调用注册的工具
import asyncio
result = asyncio.run(server.tools["multiply"](x=5, y=3))
print(result)  # 输出: 15
```

### 5. 为什么使用 [tool()](file:///mnt/workspace/06-mcp/python-sdk/src/mcp/server/fastmcp/server.py#L260-L299) 而不是直接注册？

```python
class BetterServer:
    def __init__(self):
        self.tools = {}
    
    def tool(self, name=None, description=None):
        """
        装饰器工厂，可以接受配置参数
        """
        def decorator(func):
            tool_name = name or func.__name__
            # 可以在这里处理元数据
            func.description = description
            func.registered_at = "now"
            
            # 实际注册
            self.tools[tool_name] = func
            print(f"注册工具 {tool_name}: {description}")
            return func
        return decorator

server = BetterServer()

# 可以带参数注册
@server.tool(name="计算器", description="执行加法运算")
async def add(a: int, b: int):
    return a + b

# 或者动态注册（源码中的方式）
async def subtract(a: int, b: int):
    return a - b

subtract.__name__ = "subtract"
server.tool(name="减法器", description="执行减法运算")(subtract)
```

### 总结

`self.server.tool()(tool_method)` 的核心原理是：

1. `self.server.tool()` 是一个**装饰器工厂**，返回一个装饰器
2. 返回的装饰器立即应用到 `tool_method` 上
3. 装饰器内部将函数注册到服务器的工具列表中
4. 这种方式允许在运行时动态创建和注册工具函数

这种模式在需要动态注册功能的框架中非常常见，比如 FastAPI 的路由注册、Flask 的蓝图注册等。